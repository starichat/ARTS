> 提到 MySQL 数据库的四种隔离级别，我们一定会想到事务，因为隔离级别是基于事务而衍生的。  
  
## 什么是事务？  
事务是数据库管理系统执行过程中过的一个逻辑单位，由一个有限的数据库操作序列构成。这一系列严密的操作，必须成功完成，否则在每个操作中所作的所有更改都会被撤消，也就是事务具有原子性。一个事务中的一系列的操作要么全部成功，要么一个都不做。

事务的结束有两种，当事务中的所以步骤全部成功执行时，事务成功提交。如果其中一个步骤失败，将发生回滚操作，撤消事务开始时执行的所有操作。  
  
## 事务的四个特征  
  

- **原子性**  
 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行 。  

- **一致性**  
 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。即事务执行结束后，数据库的数据是完整的、可靠的。  
  
- **隔离性**  
 一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。   

- **持久性**  
 已被提交的事务对数据库的修改应该永久保存在数据库中。接下来的其它操作或故障不应该对其执行结果有任何影响。  
  
## MySQL 数据库的四种隔离级别  
SQL 标准定义了四种隔离级别，用来限定事务的内外部可见性。低级别的隔离可以支持更高的并发处理，并且拥有更低的系统开销。  
  
#### Read Uncommitted（读未提交的内容）  
在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。读取为提交的数据，称为脏读。  
例如：  

|   事务A        |    事务B        |  
|-----------     |-----------      |
|                |  开始事务       |  
|  开始事务      |                 |  
|                |  查询余额1000元 |
|                |  取出余额200元  |
| 查询余额800元（脏读）  |                 |
|                |  撤销事务       |
| 存入金额300元，余额1100元  |                 |
| 提交事务  |                 |  
  
#### Read Committed（读取提交内容）
一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。  
例如：   

|   事务A        |    事务B        |  
|-----------     |-----------      |
|                |  开始事务       |  
|  开始事务      |                 |  
|                |  查询余额1000元 |
| 查询余额1000元  |                 |
|                |  取出余额200元  |
|                |  提交事务       |
| 查询余额800元（与之前不一致）  |                 |  
  
#### Repeatable Read（可重读）  
这是**MySQL的默认事务隔离级别**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据，但是会导致幻读问题。幻读是指当用户读取某一范围的数据时，另一个事务又在该范围内插入了新数据，当用户再读取该范围的数据行时，会发现有新的“幻影” 数据。  
  
例如：   

|   事务A        |    事务B        |  
|-----------     |-----------      |
|                |  开始事务       |  
|  开始事务      |                 |  
| 用户Z总存款1000元 |                 |
|                |  新增存款账户金额200元  |
|                |  提交事务       |
| 用户Z总存款1200元（与之前不一致）  |                 |  
  
> 幻读和不可重复读的区别在于，幻读是由于数据插入或删除引起的，而不可重复读是由于数据修改更新引起的。  
  
#### Serializable（可串行化）  
  
它是最高隔离级别，通过强制事务排序来解决幻读问题。实际上是在每个读的数据行上加共享锁，但是这样会造成大量的超时和锁竞争，提高系统性能损耗。  
  
#### 数据库中事务导致的问题  
  
- 脏读（Drity Read）：  
  
事务A已经更新了数据，事务B在此时读取了该数据，但是因为某些原因事务A发生RollBack操作，导致事务B读取的数据不正确。  
  
- 不可重复读(Non-repeatable read)：  
  
事务A的两次查询之中数据不一致，这可能是两次查询过程中间插入了事务B对原有的数据的修改操作。  
  
- 幻读(Phantom Read):  
  
事务A的两次查询之中数据行数不一致。事务A查询到部分数据行，此时事务B插入/删除了几行数据，事务A再次查询时导致查询的数据行数与之前对比不一致。