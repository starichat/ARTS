题目来自 [LeetCode 中国](https://leetcode-cn.com/)。

#### 189. 旋转数组（简单）

##### 描述：

> 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
  - 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
  - 要求使用空间复杂度为 O(1) 的原地算法。

##### 示例：

```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

##### 思路：

> 利用数组元素移动来实现，中间变量保存临时值。

##### 解法：

```
class Solution {
    public void rotate(int[] nums, int k) {
          if (nums == null || nums.length == 0) {
            return;
        }

        int length = nums.length;
        for (int i = 0; i < k; i++) {
            int temp = nums[length - 1];
            for (int j = length - 1; j > 0; j--) {
                nums[j] = nums[j - 1];
            }
            nums[0] = temp;
        }
    }
}

```

##### 分析：

- 时间复杂度：O(n)
- 空间复杂度：O(1)

-----

#### 7. 反转整数（简单）

##### 描述：

> 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

##### 示例：

```
输入: 123
输出: 321
```

##### 思路：

> 把原数字先对 10 求余，再将求余后的数字乘以 10 加上结果数字和，再将原数字除以 10，重复以上步骤，直到原数字等于 0。
> 越界通过与整形的最大值、最小值的比较来判断。

##### 解法：

```
class Solution {
    public int reverse(int x) {
        int result = 0;
        while (x != 0) {
            int d = x % 10;
            if(result > Integer.MAX_VALUE / 10 || result < Integer.MIN_VALUE / 10){
                return 0;
            }
            result = result * 10 + d;
            x /= 10;
        }
        return result;
    }
}
```

##### 分析：

- 时间复杂度：O(1)
- 空间复杂度：O(1)
